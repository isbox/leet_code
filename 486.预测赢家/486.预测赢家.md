## 486. 预测赢家

#### 递归解法

难点在于递归的最小解方向

如果使用累积值的话还需要算出对手的最优解，所以这里的思路会有点不同，换个方向“玩家与对手的分差”

当玩家选择 **队首/队尾 - 下次对手取值的差值 = 越大越好（说明自己选的大，对手选的小）**

可以的到最小递归解
`max(nums[i] - resolve(i + 1, j), nums[j] - resolve(i, j - 1))`

缓存性能提升

会遇到求解重复问题，如 resolve(i, j)，可以用 map 将结果缓存，如：`map.set('i,j', res);`

当遇到相同问题时可以直接将值取出 `map.get('i,j');`


<br/>
<br/>


#### 动态规划解法

难点在于对到 dp 公式

由题目可知，两个玩家每次只能从队首或队尾取，为了推导 dp 公式，这里有博弈，那默认每个玩家每次都会选取对自己最有利的数（能让自己总和最大）的值

这里的思路会和之前动态规划有点不一样，由于博弈的引入，如果将 dp[i][j] 单纯视为当前玩家最优选择的总和，会非常麻烦，因为不知道对手的选择；


这里需要转换下思路：

将 `dp[i][j]` 就看做玩家选择后与对手的差值，但是这里需要预测对手下次的选择
- 如果选择了队首 "i" 那么对手就有 `dp[i + 1][j]` 的选择；
- 如果选择了队尾 "j" 那么对手就有 `dp[i][j - 1]` 的选择；

当玩家做出选择后，对手必然也会做出选择，为了做出最优选择，即：**当前选择的值 - 对手下次选择的值 = 值越大越好（说明自己选的大，对手选的小）**


这样我们就可以得到动态规划公式：
`dp[i][j] = max(arr[i] - dp[i + 1][j], arr[j] - dp[i][j - 1])` 其中 `i <= j (对尾下标不能大于队首)` 

即：对手下次选择后对于玩家当前的选择仍是最优

这个公式对后手（对手）同样适用

这个时候我们就可以画表了；
拿 `[1, 3, 99, 5, 7]` 来说：

![](https://cdn.jsdelivr.net/gh/isbox/picBed/img/WX20220106-092644@2x.png)

拿 `dp[3][4], [5, 7]` 来说
- 先看对角线，对于 `i === j（只有最后一个可选）` 就等于当前位置的值，这个值就是与对手的分差；
- 如果选择的是队首，值为5(nums[3])，则对手会选择 7(dp[3 + 1][4])，分数差为 -2
- 如果选择的是队尾，值为7(nums[4])，则对手会选择 1(num[3]/nums[4 - 1])，分数差为 2
- 由于双方都会选择最优，玩家会选择7，对手会选择5，分差为2，先手优势
- ...以此类推

由于我们的视角始终为先手玩家，即使最后是对手选择也没有影响，因为决定胜负的是最终分差，分差 >= 0 先手胜，否则后手胜

所以最终结果以 dp[0][len - 1] >= 0 判断即可
